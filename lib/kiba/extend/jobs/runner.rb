# frozen_string_literal: true

require_relative 'reporter'

module Kiba
  module Extend
    module Jobs
      # The methods that need to be mixed in to a Job to make it run
      #
      # These methods are intended to be agnostic of the job segment/step logic,
      #   which is why they are separated out into a module
      module Runner
        include Reporter
        # Error raised if dependency file is still missing after we tried to run dependencies
        class MissingDependencyError < StandardError
          # @param filekey [Symbol] key for which a file path was not found in {Kiba::Extend::FileRegistry}
          def initialize(filekey, path)
            msg = "Cannot locate dependent file: #{filekey} at #{path}"
            super(msg)
          end
        end

        def add_decoration
          show_me_decoration
          tell_me_decoration
        end
        
        # Add lookup tables to the context as methods memoized to instance variables
        def add_lookup(config)
          key_as_iv = "@#{config.key}".to_sym

          context.define_singleton_method(config.key) {
            if instance_variable_defined?(key_as_iv)
              instance_variable_get(key_as_iv)
            else
              instance_variable_set(key_as_iv, Lookup.csv_to_hash(config.args))
            end
          }
        end

        # This stuff does not get handled by parsing source code
        def add_source_and_destination
          %i[config sources destinations].compact.each do |method_name|
            populate_control(method(method_name))
          end
        end

        def assemble_control
          lookups_to_memoized_methods if @files[:lookup]
          parse_job_segments
          add_source_and_destination
          add_decoration
          control
        end

        def check_requirements
          [@files[:source], @files[:lookup]].compact.flatten.each do |data|
            next unless data.path
            next if File.exist?(data.path)

            raise MissingDependencyError.new(data.key, data.path)
          end
        end

        def destinations
          @files[:destination].map { |config| file_config(config) }
        end

        def file_config(config)
          { klass: config.klass, args: config.args }
        end

        def handle_requirements
          [@files[:source], @files[:lookup]].compact.flatten.map(&:required).compact.each { |method| method.call }

          check_requirements
        end

        def lookups_to_memoized_methods
          @files[:lookup].each do |config|
            add_lookup(config)
          end
        end

        # The parts that get generated by parsing of Kiba code blocks
        def parse_job_segments
          parse_job(control, context, [pre_process, transform, post_process])
        end

        # @todo I think this may not need to be so opaque and metamagicky now that this module has
        #   direct access to one instance of context and control for all the processes, but it works
        #   now. Test/simplify later.
        def populate_control(method)
          elements = method.call
          control_method = control.method(method.name)
          target = control_method.call
          if method.name == :config
            target.merge(elements)
          else
            elements.each { |element| target << element }
          end
        end

        def show_me_decoration
          return unless Kiba::Extend.job.show_me
          
          extend ShowMeJob
          decorate
        end

        def sources
          @files[:source].map { |config| file_config(config) }
        end

        def tell_me_decoration
          return unless Kiba::Extend.job.tell_me
          
          extend TellMeJob
          decorate
        end

        def transform
          [initial_transforms, @transformer, final_transforms].flatten
        end
      end
    end
  end
end
