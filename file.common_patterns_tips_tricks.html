<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: Common patterns, tips, and tricks
  
    &mdash; Kiba-Extend Documentation
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "common_patterns_tips_tricks";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: Common patterns, tips, and tricks</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'>
<h1 id="common-patterns-tips-and-tricks">Common patterns, tips, and tricks</h1>

<!-- toc -->

<ul>
  <li><a href="#debugging-with-pry">Debugging with <code>pry</code></a></li>
  <li><a href="#multi-source-jobs-with-csv-destination-and-sources-dont-have-all-the-same-fields">Multi-source jobs with CSV destination and sources don’t have all the same fields</a></li>
  <li><a href="#using-transforms-within-another-transform">Using transform(s) within another transform</a></li>
  <li><a href="#using-transforms-in-job-definitions">Using transforms in job definitions</a></li>
  <li><a href="#calling-a-job-with-parameters">Calling a job with parameters</a></li>
  <li><a href="#automating-repetitive-file-registry">Automating repetitive file registry</a></li>
  <li><a href="#running-jobs-and-checking-srcrows-and-outrows-counts-from-client-project-code">Running jobs, and checking <code>srcrows</code> and <code>outrows</code> counts from client project code</a></li>
</ul>

<!-- tocstop -->

<h2 id="debugging-with-pry">Debugging with <code>pry</code></h2>

<p>In most parts of a kiba-extend project, you can just put a <code>binding.pry</code> breakpoint anywhere in the code and it will work.</p>

<p>There are two exceptions to this: inside <code>Kiba.job_segment</code> blocks, and in any code where the breakpoint context interacts with the <code>dry-rb</code> gems that are used to build kiba-extend’s registry and config functionality.</p>

<h3 id="in-kibajobsegment-blocks">In <code>Kiba.job_segment</code> blocks</h3>

<p>Wrap your breakpoint in an inline transform:</p>

<pre class="code language-ruby"><code class="language-ruby">transform do |row|
  binding.pry
  row
end
</code></pre>

<p>Note that you can set the breakpoint conditionally, if you want to see what’s going on at this point in the job for rows with certain characteristics:</p>

<pre class="code language-ruby"><code class="language-ruby">transform do |row|
  binding.pry if row[:id]&amp;.start_with?(&quot;A&quot;)
  row
end
</code></pre>

<h3 id="where-bindingpry-conflicts-with-dry-rb-gem-code-or-other-code">Where <code>binding.pry</code> conflicts with <code>dry-rb</code> gem code or other code</h3>

<p>It can be hard to predict when/where this is going to happen, but sometimes entering a <code>binding.pry</code> breakpoint in your code can result in the following kind of error:</p>

<pre class="code ruby"><code class="ruby">RuntimeError:
        Cannot create Binding object for non-Ruby caller
</code></pre>

<p>Basically, any error message about <a href="https://ruby-doc.org/3.4.1/Binding.html">Binding objects</a> means the breakpoint is getting misinterpreted based on other code around it.</p>

<p>The fix is easy: change your breakpoint to <code>Kernel.binding.pry</code>. This ensures <code>binding</code> is interpreted as the default method available on all Ruby objects via <a href="https://ruby-doc.org/3.4.1/Kernel.html">Kernel</a>.</p>

<h2 id="multi-source-jobs-with-csv-destination-and-sources-dont-have-all-the-same-fields">Multi-source jobs with CSV destination and sources don’t have all the same fields</h2>

<p><strong>Works for <code>Kiba::Extend::Destinations::CSV</code> destinations only</strong></p>

<p>If you have multiple sources for a job, writing to a CSV destination will fail if all rows in all sources do not have exactly the same fields.</p>

<p>Especially when joining data from many tables, manually ensuring columns stay in sync across all sources is very tedious, especially as you are developing a set of jobs.</p>

<p><strong>Recommended solution:</strong> As of 4.0.0, you can fix this by adding <code>transform Clean::EnsureConsistentFields</code> to the end of tranform logic for multi-source jobs that output to CSV.</p>

<p><strong>Legacy solution (not recommended):</strong> <code>Kiba::Extend::Utils::MultiSourceNormalizer</code> and <code>Kiba::Extend::Jobs::MultiSourcePrepJob</code> were introduced in v2.7.0 to address this issue, but will eventually be deprecated, as the <code>EnsureConsistentFields</code> transform is much easier to set up and use.</p>

<h2 id="using-transforms-within-another-transform">Using transform(s) within another transform</h2>

<h3 id="aliasingrenaming-a-transform">Aliasing/renaming a transform</h3>

<p>This pattern is used with argument forwarding to deprecate/rename some transforms in kiba-extend, as shown below:</p>

<pre class="code language-ruby"><code class="language-ruby">class Transformer
  def initialize(...)
    @xform = MyOtherTransformer.new(...)
  end

  def process(row)
    xform.process(row)
	row
  end

  private

  attr_reader :xform
end
</code></pre>

<h3 id="adding-some-extra-behavior-to-an-existing-transform-in-a-new-transform">Adding some extra behavior to an existing transform in a new transform</h3>

<p>It can also be used in order to compose additional behavior in another transform as shown below:</p>

<pre class="code language-ruby"><code class="language-ruby">class NewTransformer
  def initialize(param1:, param2:)
    @param1 = param1
	@param2 = param2
	@xform = ExistingTransformer.new(opt1: :something)
  end

  def process(row)
    row[:field1] = param1
    xform.process(row) # calls the other transformer on the row
    row[:field2] = param2
	row
  end

  private

  attr_reader :param1, :param2, :xform
end
</code></pre>

<p>See the code for <code>Kiba::Extend::Transforms::Rename::Fields</code> for a simple example of embedding another transform to compose transformation logic.</p>

<p>See <code>Kiba::Extend::Transforms::Collapse::FieldsToRepeatableFieldGroup</code> for a complex example, involving many other transforms.</p>

<h3 id="chaining-multiple-transforms-in-another-transform">Chaining multiple transforms in another transform</h3>

<p>I often use this if I need to define a single, client-specific data cleanup transform class to be run from within kiba-tms, kiba-pastperfect_we, etc.</p>

<p>You can do:</p>

<pre class="code language-ruby"><code class="language-ruby">class NewTransformer
  def initialize(...)
    @xforms = [
	  ExitingTransformer.new(...),
	  AnotherTransformer.new(...),
	  ThirdTransformer.new(...)
	]
  end

  # @private
  def process(row)
    xforms.each{ |xform| xform.process(row) }
	row
  end

  private

  attr_reader :xforms
end
</code></pre>

<h3 id="limitations-on-the-above">LIMITATIONS ON THE ABOVE</h3>

<p>All of the above patterns should work with normal transforms—those that process one row at a time and always return that row.</p>

<p>Be careful including the following types of transforms in any of the above patterns:</p>

<ul>
  <li><strong>Transforms that sometimes return the row and sometimes return nil.</strong> Example: all the <code>Kiba::Extend::Transforms::FilterRows</code> transforms.</li>
  <li><strong>Transforms that can output more than one row from a given input row.</strong> The <code>:process</code> method of such transforms will <code>yield</code> rows and return <code>nil</code>. Example: <code>Kiba::Extend::Transforms::Explode::RowsFromMultivalField</code></li>
  <li><strong>Transforms that work on multiple rows (or the whole table) at a time</strong> Such transforms will have a <code>:close</code> method that returns or yields rows. The <code>:process</code> method of such transforms will generally push rows to an accumulator Array or Hash defined as a class instance variable, and return <code>nil</code>. The <code>:close</code> method typically operates on the contents of the accumulator once all rows have been pushed into it. Example: <code>Kiba::Extend::Transforms::Deduplicate::Table</code></li>
</ul>

<p>These might work ok, but I haven’t done enough testing to verify they are actually safe. Try it and see. If they work, make a PR to update this documentation!</p>

<h2 id="using-transforms-in-job-definitions">Using transforms in job definitions</h2>

<p>The following code snippets are equivalent.</p>

<p>This one relies on the domain specific language (DSL) “magic” defined in kiba:</p>

<pre class="code language-ruby"><code class="language-ruby">Kiba.job_segment do
  transform Merge::ConstantValue, target: :data_source, value: &#39;source system&#39;
end
</code></pre>

<p>This one uses plain Ruby to set up two differently configured <code>Merge::ConstantValue</code> transform classes in the context of the job’s transform logic. It then uses kiba’s inline block transform functionality to call the appropriate transform’s <code>:process</code> method on each row, depending on whether the :id field in the row starts with the given string:</p>

<pre class="code language-ruby"><code class="language-ruby">Kiba.job_segment do
  exsrc = Merge::ConstantValue.new(target: :data_source, value: &quot;spreadsheets&quot;)
  dbsrc = Merge::ConstantValue.new(target: :data_source, value: &quot;database&quot;)
  transform do |row|
    idval = row[:id]
	if idval.start_with?(&quot;ACC&quot;)
	  dbsrc.process(row)
	else
	  exsrc.process(row)
	end
	# You don&#39;t need to return &quot;row&quot; here because calling `:process` on a
	#   `Merge::ConstantValue` transform returns a row
  end
end
</code></pre>

<p>This is a silly, contrived, example that offers no benefits over just doing the whole thing in the block transform:</p>

<pre class="code language-ruby"><code class="language-ruby">Kiba.job_segment do
  transform do |row|
    idval = row[:id]
	target = :data_source
	row[target] = if idval.start_with?(&quot;ACC&quot;)
	  &quot;database&quot;
	else
	  &quot;spreadsheets&quot;
	end

	row # A block transform must return `nil` or a row.
  end
end
</code></pre>

<p>However, you might run into ways where you need to use transforms more flexibly, and this basic idea might help.</p>

<h2 id="calling-a-job-with-parameters">Calling a job with parameters</h2>

<p>No need to write repetitive jobs with the exact same logic to handle variable values that differ according to a pattern. See <a href="https://lyrasis.github.io/kiba-extend/file.file_registry_entry.html#hash-creator-example-since-2-7-2">File registry documentation on Hash creator</a> for a full example of how to do this.</p>

<h2 id="automating-repetitive-file-registry">Automating repetitive file registry</h2>

<p>The basic idea of this is:</p>

<ul>
  <li>write code that generates <code>Project.registry</code> <code>register</code> commands with registry keys and hashes, according to the necessary pattern.</li>
  <li>call this code from within <code>Project::RegistryData.register</code> before <code>register_files</code> is called.</li>
</ul>

<p>One pattern for doing this is publicly viewable <a href="https://github.com/lyrasis/csws-update/blob/main/lib/csws/registry_data.rb#L7-L15">in the <code>kiba-tms</code> project</a>. <code>register_supplied_files</code> automates registry of the original TMS CSV files included in the project. <code>register_prep_files</code> automates the creation of entries for all original files into a <code>prep</code> namespace. If a custom prep method or module has been creating matching the name pattern, it will be used as the creator. Otherwise, the creator will be <a href="https://github.com/lyrasis/kiba-tms/blob/main/lib/kiba/tms/jobs/abstract_prep.rb"><code>Kiba::Tms::Jobs::AbstractPrep</code></a>, which removes TMS-specific fields and deletes any empty fields.</p>

<p>Another example (in LYRASIS private repo) is <a href="https://github.com/lyrasis/csws-update/blob/main/lib/csws/registry_data.rb#L7-L15">here</a>.</p>

<h2 id="running-jobs-and-checking-srcrows-and-outrows-counts-from-client-project-code">Running jobs, and checking <code>srcrows</code> and <code>outrows</code> counts from client project code</h2>

<p>Since 3.1.0, you can do this from any project using <code>kiba-extend</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_job'>job</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Kiba.html" title="Kiba (module)">Kiba</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Kiba/Extend.html" title="Kiba::Extend (module)">Extend</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Kiba/Extend/Command.html" title="Kiba::Extend::Command (module)">Command</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Kiba/Extend/Command/Run.html" title="Kiba::Extend::Command::Run (module)">Run</a></span></span><span class='period'>.</span><span class='id identifier rubyid_job'><span class='object_link'><a href="Kiba/Extend/Command/Run.html#job-class_method" title="Kiba::Extend::Command::Run.job (method)">job</a></span></span><span class='lparen'>(</span><span class='symbol'>:prep__objects</span><span class='rparen'>)</span>
<span class='id identifier rubyid_puts'>puts</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Some records omitted</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>if</span> <span class='id identifier rubyid_job'>job</span><span class='period'>.</span><span class='id identifier rubyid_outrows'>outrows</span> <span class='op'>&lt;</span> <span class='id identifier rubyid_job'>job</span><span class='period'>.</span><span class='id identifier rubyid_srcrows'>srcrows</span>
</code></pre>

<p>This assumes <code>:prep__objects</code> is registered as a job.</p>

<p>This is being used in the publicly available <code>kiba-tms</code> project, in the auto-config generation and to-do check processes. <a href="https://github.com/lyrasis/kiba-tms/search?q=Kiba%3A%3AExtend%3A%3ACommand%3A%3ARun.job">Examples</a></p>

<p>Since 4.0.0, you can use <a href="https://lyrasis.github.io/kiba-extend/Kiba/Extend/Job.html#output%3F-class_method">the <code>Kiba::Extend::Job.output?</code> method</a> to check that a job writes a file with actual data rows in it. This is helpful if you start writing dynamic/reusable code for projects that might not all have the exact same data. You can conditionally run some parts of a pipeline, only if the data is present.</p>
</div></div>

      <div id="footer">
  Generated on Wed Dec 10 17:09:49 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-3.4.7).
</div>

    </div>
  </body>
</html>